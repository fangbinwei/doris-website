"use strict";(self.webpackChunkselectdb_portal=self.webpackChunkselectdb_portal||[]).push([[38568],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var u=a.createContext({}),s=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(u.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,u=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(n),m=i,h=d["".concat(u,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},98282:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=n(87462),i=(n(67294),n(3905));const o={title:"Orthogonal BITMAP calculation UDAF",language:"en"},r=void 0,l={unversionedId:"extending-doris/udf/contrib/udaf-orthogonal-bitmap-manual",id:"version-0.15/extending-doris/udf/contrib/udaf-orthogonal-bitmap-manual",title:"Orthogonal BITMAP calculation UDAF",description:"\x3c!--",source:"@site/versioned_docs/version-0.15/extending-doris/udf/contrib/udaf-orthogonal-bitmap-manual.md",sourceDirName:"extending-doris/udf/contrib",slug:"/extending-doris/udf/contrib/udaf-orthogonal-bitmap-manual",permalink:"/docs/0.15/extending-doris/udf/contrib/udaf-orthogonal-bitmap-manual",draft:!1,tags:[],version:"0.15",frontMatter:{title:"Orthogonal BITMAP calculation UDAF",language:"en"},sidebar:"docs",previous:{title:"User Defined Function",permalink:"/docs/0.15/extending-doris/udf/user-defined-function"},next:{title:"curdate",permalink:"/docs/0.15/sql-reference/sql-functions/date-time-functions/curdate"}},u={},s=[{value:"Background",id:"background",level:2},{value:"User guide",id:"user-guide",level:2},{value:"Create table",id:"create-table",level:3},{value:"Data Load",id:"data-load",level:3},{value:"Source code and compilation",id:"source-code-and-compilation",level:3},{value:"Register the UDAF with DORIS",id:"register-the-udaf-with-doris",level:3},{value:"orthogonal_bitmap_intersect",id:"orthogonal_bitmap_intersect",level:4},{value:"orthogonal_bitmap_intersect_count",id:"orthogonal_bitmap_intersect_count",level:4},{value:"orthogonal_bitmap_union_count",id:"orthogonal_bitmap_union_count",level:4},{value:"Suitable for the scene",id:"suitable-for-the-scene",level:3}],c={toc:s};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"orthogonal-bitmap-calculation-udaf"},"Orthogonal BITMAP calculation UDAF"),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"The original bitmap aggregate function designed by Doris is more general, but it has poor performance for the intersection and union of bitmap large cardinality above 100 million level. There are two main reasons for checking the bitmap aggregate function logic of the back-end be. First, when the bitmap cardinality is large, if the bitmap data size exceeds 1g, the network / disk IO processing time is relatively long; second, after the scan data, all the back-end be instances are transmitted to the top-level node for intersection and union operation, which brings pressure on the top-level single node and becomes the processing bottleneck."),(0,i.kt)("p",null,"The solution is to divide the bitmap column values according to the range, and the values of different ranges are stored in different buckets, so as to ensure that the bitmap values of different buckets are orthogonal and the data distribution is more uniform. In the case of query, the orthogonal bitmap in different buckets is firstly aggregated and calculated, and then the top-level node directly combines and summarizes the aggregated calculated values and outputs them. This will greatly improve the computing efficiency and solve the bottleneck problem of the top single node computing."),(0,i.kt)("h2",{id:"user-guide"},"User guide"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Create a table and add hid column to represent bitmap column value ID range as hash bucket column"),(0,i.kt)("li",{parentName:"ol"},"Data tank library: When loading data, divide the range of bitmap column values"),(0,i.kt)("li",{parentName:"ol"},"Compile UDAF and produce. So dynamic library"),(0,i.kt)("li",{parentName:"ol"},"Register the UDAF in DORIS, which loads the.so library at run time"),(0,i.kt)("li",{parentName:"ol"},"Usage scenarios")),(0,i.kt)("h3",{id:"create-table"},"Create table"),(0,i.kt)("p",null,"We need to use the aggregation model when building tables. The data type is bitmap, and the aggregation function is bitmap_ union"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'CREATE TABLE `user_tag_bitmap` (\n  `tag` bigint(20) NULL COMMENT "user tag",\n  `hid` smallint(6) NULL COMMENT "Bucket ID",\n  `user_id` bitmap BITMAP_UNION NULL COMMENT ""\n) ENGINE=OLAP\nAGGREGATE KEY(`tag`, `hid`)\nCOMMENT "OLAP"\nDISTRIBUTED BY HASH(`hid`) BUCKETS 3\n')),(0,i.kt)("p",null,"The HID column is added to the table schema to indicate the ID range as a hash bucket column."),(0,i.kt)("p",null,"Note: the HID number and buckets should be set reasonably, and the HID number should be set at least 5 times of buckets, so as to make the data hash bucket division as balanced as possible"),(0,i.kt)("h3",{id:"data-load"},"Data Load"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"LOAD LABEL user_tag_bitmap_test\n(\nDATA INFILE('hdfs://abc')\nINTO TABLE user_tag_bitmap\nCOLUMNS TERMINATED BY ','\n(tmp_tag, tmp_user_id)\nSET (\ntag = tmp_tag,\nhid = ceil(tmp_user_id/5000000),\nuser_id = to_bitmap(tmp_user_id)\n)\n)\n...\n")),(0,i.kt)("p",null,"Data format:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"11111111,1\n11111112,2\n11111113,3\n11111114,4\n...\n")),(0,i.kt)("p",null,"Note: the first column represents the user tags, which have been converted from Chinese into numbers"),(0,i.kt)("p",null,"When loading data, vertically cut the bitmap value range of the user. For example, the hid value of the user ID in the range of 1-5000000 is the same, and the row with the same HID value will be allocated into a sub-bucket, so that the bitmap value in each sub-bucket is orthogonal. On the UDAF implementation of bitmap, the orthogonal feature of bitmap value in the bucket can be used to perform intersection union calculation, and the calculation results will be shuffled to the top node for aggregation."),(0,i.kt)("h3",{id:"source-code-and-compilation"},"Source code and compilation"),(0,i.kt)("p",null,"Source code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"contrib/udf/src/udaf_orthogonal_bitmap/\n|-- bitmap_value.h\n|-- CMakeLists.txt\n|-- orthogonal_bitmap_function.cpp\n|-- orthogonal_bitmap_function.h\n -- string_value.h\n")),(0,i.kt)("p",null,"Compile udaf:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$cd contrib/udf\n$ sh build_udf.sh\n\n")),(0,i.kt)("p",null,"libudaf_orthogonal_bitmap.so output directory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"output/contrib/udf/lib/udaf_orthogonal_bitmap/libudaf_orthogonal_bitmap.so\n")),(0,i.kt)("h3",{id:"register-the-udaf-with-doris"},"Register the UDAF with DORIS"),(0,i.kt)("p",null,"Setting parameters before Doris query"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"set parallel_fragment_exec_instance_num=5\n")),(0,i.kt)("p",null,"Note: set concurrency parameters according to cluster conditions to improve concurrent computing performance"),(0,i.kt)("p",null,"The new UDAF aggregate function is created in mysql client link Session. It is created by registering the function symbol, which is loaded as a dynamic library. "),(0,i.kt)("h4",{id:"orthogonal_bitmap_intersect"},"orthogonal_bitmap_intersect"),(0,i.kt)("p",null,"The bitmap intersection function"),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("p",null,"orthogonal_bitmap_intersect(bitmap_column, column_to_filter, filter_values)"),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("p",null,"the first parameter is the bitmap column, the second parameter is the dimension column for filtering, and the third parameter is the variable length parameter, which means different values of the filter dimension column"),(0,i.kt)("p",null,"Explain:"),(0,i.kt)("p",null,"on the basis of this table schema, this udaf has two levels of aggregation in query planning. In the first layer, be nodes (update and serialize) first press filter_ Values are used to hash aggregate the keys, and then the bitmaps of all keys are intersected. The results are serialized and sent to the second level be nodes (merge and finalize). In the second level be nodes, all the bitmap values from the first level nodes are combined circularly"),(0,i.kt)("p",null,"Create UDAF:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'drop FUNCTION orthogonal_bitmap_intersect(BITMAP,BIGINT,BIGINT, ...);\nCREATE AGGREGATE FUNCTION orthogonal_bitmap_intersect(BITMAP,BIGINT,BIGINT, ...) RETURNS BITMAP INTERMEDIATE varchar(1)\nPROPERTIES (\n"init_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions21bitmap_intersect_initIlNS_9BigIntValEEEvPNS_15FunctionContextEPNS_9StringValE",\n"update_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions23bitmap_intersect_updateIlNS_9BigIntValEEEvPNS_15FunctionContextERKNS_9StringValERKT0_iPS9_PS6_",\n"serialize_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions30bitmap_intersect_and_serializeIlEENS_9StringValEPNS_15FunctionContextERKS2_",\n"merge_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions12bitmap_unionEPNS_15FunctionContextERKNS_9StringValEPS3_",\n"finalize_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions16bitmap_serializeEPNS_15FunctionContextERKNS_9StringValE",\n"object_file"="http://ip:port/libudaf_orthogonal_bitmap.so" );\n\n')),(0,i.kt)("p",null,"Note:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"column_to_filter, filter_values column is set to bigint type here;")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"the function symbol passes through nm /xxx/xxx/libudaf",(0,i.kt)("em",{parentName:"p"},'orthogonal_bitmap.so|grep "bitmap'),'" '))),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"select BITMAP_COUNT(orthogonal_bitmap_intersect(user_id, tag, 13080800, 11110200)) from user_tag_bitmap  where tag in (13080800, 11110200);\n\n")),(0,i.kt)("h4",{id:"orthogonal_bitmap_intersect_count"},"orthogonal_bitmap_intersect_count"),(0,i.kt)("p",null,"To calculate the bitmap intersection count function, the syntax is the same as the original Intersect_Count, but the implementation is different"),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("p",null,"orthogonal_bitmap_intersect_count(bitmap_column, column_to_filter, filter_values)"),(0,i.kt)("p",null,"Parameters:"),(0,i.kt)("p",null,"The first parameter is the bitmap column, the second parameter is the dimension column for filtering, and the third parameter is the variable length parameter, which means different values of the filter dimension column"),(0,i.kt)("p",null,"Explain:"),(0,i.kt)("p",null,"on the basis of this table schema, the query planning aggregation is divided into two layers. In the first layer, be nodes (update and serialize) first press filter_ Values are used to hash aggregate the keys, and then the intersection of bitmaps of all keys is performed, and then the intersection results are counted. The count values are serialized and sent to the second level be nodes (merge and finalize). In the second level be nodes, the sum of all the count values from the first level nodes is calculated circularly"),(0,i.kt)("p",null,"Create UDAF:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'drop FUNCTION orthogonal_bitmap_intersect_count(BITMAP,BIGINT,BIGINT, ...);\nCREATE AGGREGATE FUNCTION orthogonal_bitmap_intersect_count(BITMAP,BIGINT,BIGINT, ...) RETURNS BIGINT INTERMEDIATE varchar(1)\nPROPERTIES (\n"init_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions27bitmap_intersect_count_initIlNS_9BigIntValEEEvPNS_15FunctionContextEPNS_9StringValE",\n"update_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions23bitmap_intersect_updateIlNS_9BigIntValEEEvPNS_15FunctionContextERKNS_9StringValERKT0_iPS9_PS6_",\n"serialize_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions32bitmap_intersect_count_serializeIlEENS_9StringValEPNS_15FunctionContextERKS2_",\n"merge_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions18bitmap_count_mergeEPNS_15FunctionContextERKNS_9StringValEPS3_",\n"finalize_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions21bitmap_count_finalizeEPNS_15FunctionContextERKNS_9StringValE",\n"object_file"="http://ip:port/libudaf_orthogonal_bitmap.so" );\n')),(0,i.kt)("h4",{id:"orthogonal_bitmap_union_count"},"orthogonal_bitmap_union_count"),(0,i.kt)("p",null,"Figure out the bitmap union count function, syntax with the original bitmap_union_count, but the implementation is different."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("p",null,"orthogonal_bitmap_union_count(bitmap_column)"),(0,i.kt)("p",null,"Explain:"),(0,i.kt)("p",null,"on the basis of this table schema, this udaf is divided into two layers. In the first layer, be nodes (update and serialize) merge all the bitmaps, and then count the resulting bitmaps. The count values are serialized and sent to the second level be nodes (merge and finalize). In the second layer, the be nodes are used to calculate the sum of all the count values from the first level nodes"),(0,i.kt)("p",null,"Create UDAF:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'drop FUNCTION orthogonal_bitmap_union_count(BITMAP);\nCREATE AGGREGATE FUNCTION orthogonal_bitmap_union_count(BITMAP) RETURNS BIGINT INTERMEDIATE varchar(1)\nPROPERTIES (\n"init_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions23bitmap_union_count_initEPNS_15FunctionContextEPNS_9StringValE",\n"update_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions12bitmap_unionEPNS_15FunctionContextERKNS_9StringValEPS3_",\n"serialize_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions22bitmap_count_serializeEPNS_15FunctionContextERKNS_9StringValE",\n"merge_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions18bitmap_count_mergeEPNS_15FunctionContextERKNS_9StringValEPS3_",\n"finalize_fn"="_ZN9doris_udf25OrthogonalBitmapFunctions21bitmap_count_finalizeEPNS_15FunctionContextERKNS_9StringValE",\n"object_file"="http://ip:port/libudaf_orthogonal_bitmap.so" );\n')),(0,i.kt)("h3",{id:"suitable-for-the-scene"},"Suitable for the scene"),(0,i.kt)("p",null,"It is consistent with the scenario of orthogonal calculation of bitmap, such as calculation retention, funnel, user portrait, etc."),(0,i.kt)("p",null,"Crowd selection:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"select orthogonal_bitmap_intersect_count(user_id, tag, 13080800, 11110200) from user_tag_bitmap where tag in (13080800, 11110200);\n\nNote: 13080800 and 11110200 represent user labels\n")),(0,i.kt)("p",null,"Calculate the deduplication value for user_id:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"select orthogonal_bitmap_union_count(user_id) from user_tag_bitmap where tag in (13080800, 11110200);\n")))}d.isMDXComponent=!0}}]);