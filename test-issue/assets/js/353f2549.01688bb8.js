"use strict";(self.webpackChunkselectdb_portal=self.webpackChunkselectdb_portal||[]).push([[75626],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>c});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},E="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},T=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),E=s(t),T=i,c=E["".concat(p,".").concat(T)]||E[T]||d[T]||r;return t?a.createElement(c,o(o({ref:n},m),{},{components:t})):a.createElement(c,o({ref:n},m))}));function c(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=T;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[E]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}T.displayName="MDXCreateElement"},85593:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>E,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=t(87462),i=(t(67294),t(3905));const r={title:"CREATE TABLE",language:"en"},o=void 0,l={unversionedId:"sql-reference/sql-statements/Data-Definition/CREATE-TABLE",id:"version-0.15/sql-reference/sql-statements/Data-Definition/CREATE-TABLE",title:"CREATE TABLE",description:"\x3c!--",source:"@site/versioned_docs/version-0.15/sql-reference/sql-statements/Data-Definition/CREATE-TABLE.md",sourceDirName:"sql-reference/sql-statements/Data-Definition",slug:"/sql-reference/sql-statements/Data-Definition/CREATE-TABLE",permalink:"/docs/0.15/sql-reference/sql-statements/Data-Definition/CREATE-TABLE",draft:!1,tags:[],version:"0.15",frontMatter:{title:"CREATE TABLE",language:"en"},sidebar:"docs",previous:{title:"CREATE TABLE LIKE",permalink:"/docs/0.15/sql-reference/sql-statements/Data-Definition/CREATE-TABLE-LIKE"},next:{title:"CREATE VIEW",permalink:"/docs/0.15/sql-reference/sql-statements/Data-Definition/CREATE-VIEW"}},p={},s=[{value:"description",id:"description",level:2},{value:"example",id:"example",level:2},{value:"keyword",id:"keyword",level:2}],m={toc:s};function E(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"create-table"},"CREATE TABLE"),(0,i.kt)("h2",{id:"description"},"description"),(0,i.kt)("p",null,"This statement is used to create table\nSyntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'    CREATE [EXTERNAL] TABLE [IF NOT EXISTS] [database.]table_name\n    (column_definition1[, column_definition2, ...]\n    [, index_definition1[, ndex_definition12,]])\n    [ENGINE = [olap|mysql|broker|hive]]\n    [key_desc]\n    [COMMENT "table comment"]\n    [partition_desc]\n    [distribution_desc]\n    [rollup_index]\n    [PROPERTIES ("key"="value", ...)]\n    [BROKER PROPERTIES ("key"="value", ...)];\n')),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"column_definition\nSyntax:\n",(0,i.kt)("inlineCode",{parentName:"p"},'col_name col_type [agg_type] [NULL | NOT NULL] [DEFAULT "default_value"]'),"\nExplain:\ncol_name: Name of column\ncol_type: Type of column"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"    BOOLEAN(1 Byte)\n        Range: {0,1}\n    TINYINT(1 Byte)\n        Range: -2^7 + 1 ~ 2^7 - 1\n    SMALLINT(2 Bytes)\n        Range: -2^15 + 1 ~ 2^15 - 1\n    INT(4 Bytes)\n        Range: -2^31 + 1 ~ 2^31 - 1\n    BIGINT(8 Bytes)\n        Range: -2^63 + 1 ~ 2^63 - 1\n    LARGEINT(16 Bytes)\n        Range: -2^127 + 1 ~ 2^127 - 1\n    FLOAT(4 Bytes)\n        Support scientific notation\n    DOUBLE(8 Bytes)\n        Support scientific notation\n    DECIMAL[(precision, scale)] (16 Bytes)\n        Default is DECIMAL(10, 0)\n        precision: 1 ~ 27\n        scale: 0 ~ 9\n        integer part: 1 ~ 18\n        fractional part: 0 ~ 9\n        Not support scientific notation\n    DATE(3 Bytes)\n        Range: 0000-01-01 ~ 9999-12-31\n    DATETIME(8 Bytes)\n        Range: 0000-01-01 00:00:00 ~ 9999-12-31 23:59:59\n    CHAR[(length)]\n        Fixed length string. Range: 1 ~ 255. Default: 1\n    VARCHAR[(length)]\n        Variable length string. Range: 1 ~ 65533\n    HLL (1~16385 Bytes)\n        HLL tpye, No need to specify length.\n        This type can only be queried by hll_union_agg, hll_cardinality, hll_hash functions.\n    BITMAP\n        BITMAP type, No need to specify length. Represent a set of unsigned bigint numbers, the largest element could be 2^64 - 1\n")),(0,i.kt)("p",{parentName:"li"},"agg_type: Aggregation type. If not specified, the column is key column. Otherwise, the column   is value column."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"SUM\u3001MAX\u3001MIN\u3001REPLACE"),(0,i.kt)("li",{parentName:"ul"},"HLL_UNION: Only for HLL type"),(0,i.kt)("li",{parentName:"ul"},"REPLACE_IF_NOT_NULL: The meaning of this aggregation type is that substitution will occur if and only if the newly imported data is a non-null value. If the newly imported data is null, Doris will still retain the original value. Note: if NOT NULL is specified in the REPLACE_IF_NOT_NULL column when the user creates the table, Doris will convert it to NULL and will not report an error to the user. Users can leverage this aggregate type to achieve importing some of columns."),(0,i.kt)("li",{parentName:"ul"},"BITMAP_UNION: Only for BITMAP type\nAllow NULL: Default is NOT NULL. NULL value should be represented as ",(0,i.kt)("inlineCode",{parentName:"li"},"\\N")," in load source file.\nNotice: The origin value of BITMAP_UNION column should be TINYINT, SMALLINT, INT, BIGINT."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"index_definition\nSyntax:\n",(0,i.kt)("inlineCode",{parentName:"p"},"INDEX index_name (col_name[, col_name, ...]) [USING BITMAP] COMMENT 'xxxxxx'"),"\nExplain:\nindex_name: index name\ncol_name: column name\nNotice:\nOnly support BITMAP index in current version, BITMAP can only apply to single column")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"ENGINE type\nDefault is olap. Options are: olap, mysql, broker, hive\n1) For mysql, properties should include:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'```\nPROPERTIES (\n    "host" = "mysql_server_host",\n    "port" = "mysql_server_port",\n    "user" = "your_user_name",\n    "password" = "your_password",\n    "database" = "database_name",\n    "table" = "table_name"\n)\n```\n')),(0,i.kt)("p",{parentName:"li"},'Notice:\n"table_name" is the real table name in MySQL database.\ntable_name in CREATE TABLE stmt is table is Doris. They can be different or same.\nMySQL table created in Doris is for accessing data in MySQL database.\nDoris does not maintain and store any data from MySQL table.\n2) For broker, properties should include:'),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'```\nPROPERTIES (\n    "broker_name" = "broker_name",\n    "path" = "file_path1[,file_path2]",\n    "column_separator" = "value_separator"\n    "line_delimiter" = "value_delimiter"\n)\n```\n\n```\nBROKER PROPERTIES(\n    "username" = "name",\n    "password" = "password"\n)\n```\n\nFor different broker, the broker properties are different\n')),(0,i.kt)("p",{parentName:"li"},'Notice:\nFiles name in "path" is separated by ",". If file name includes ",", use "%2c" instead.     If file name includes "%", use "%25" instead.\nSupport CSV and Parquet. Support GZ, BZ2, LZ4, LZO(LZOP)\n3) For hive, properties should include:'),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'```\nPROPERTIES (\n    "database" = "hive_db_name",\n    "table" = "hive_table_name",\n    "hive.metastore.uris" = "thrift://127.0.0.1:9083"\n)\n```\n"database" is the name of the database corresponding to the hive table, "table" is the name of the hive table, and "hive.metastore.uris" is the hive metastore service address.\nNotice: At present, hive external tables are only used for Spark Load and query is not supported.\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"key_desc\nSyntax:\nkey_type(k1","[,k2 ...]",")\nExplain:\nData is order by specified key columns. And has different behaviors for different key  desc.\nAGGREGATE KEY:\nvalue columns will be aggregated is key columns are same.\nUNIQUE KEY:\nThe new incoming rows will replace the old rows if key columns are same.\nDUPLICATE KEY:\nAll incoming rows will be saved.\nthe default key_type is DUPLICATE KEY, and key columns are first 36 bytes of the columns    in define order.\nIf the number of columns in the first 36 is less than 3, the first 3 columns will be   used.\nNOTICE:\nExcept for AGGREGATE KEY, no need to specify aggregation type for value columns.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"partition_desc\nCurrently, both RANGE and LIST partitioning methods are supported.\n5.1 RANGE partition\nRANGE Partition has two ways to use:\n1) LESS THAN\nSyntax:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'    ```\n    PARTITION BY RANGE (k1, k2, ...)\n    (\n    PARTITION partition_name1 VALUES LESS THAN MAXVALUE|("value1", "value2", ...),\n    PARTITION partition_name2 VALUES LESS THAN MAXVALUE|("value1", "value2", ...)\n    ...\n    )\n    ```\n\nExplain:\n    Use the specified key column and the specified range of values for partitioning.\n    1) Partition name only support [A-z0-9_]\n    2) Partition key column\'s type should be:\n        TINYINT, SMALLINT, INT, BIGINT, LARGEINT, DATE, DATETIME\n    3) The range is [closed, open). And the lower bound of first partition is MIN VALUE of  specified column type.\n    4) NULL values should be save in partition which includes MIN VALUE.\n    5) Support multi partition columns, the the default partition value is MIN VALUE.\n2\uff09Fixed Range\nSyntax:\n    ```\n    PARTITION BY RANGE (k1, k2, k3, ...)\n    (\n    PARTITION partition_name1 VALUES [("k1-lower1", "k2-lower1", "k3-lower1",...),  ("k1-upper1", "k2-upper1", "k3-upper1", ...)),\n    PARTITION partition_name2 VALUES [("k1-lower1-2", "k2-lower1-2", ...), ("k1-upper1-2",  MAXVALUE, ))\n    "k3-upper1-2", ...\n    )\n    ```\nExplain:\n    1\uff09The Fixed Range is more flexible than the LESS THAN, and the left and right intervals    are completely determined by the user.\n    2\uff09Others are consistent with LESS THAN.\n')),(0,i.kt)("p",{parentName:"li"},"5.2 LIST partition\nLIST partition is divided into single column partition and multi-column partition\n1) Single column partition\nSyntax."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'    ```\n        PARTITION BY LIST(k1)\n        (\n        PARTITION partition_name1 VALUES IN ("value1", "value2", ...) ,\n        PARTITION partition_name2 VALUES IN ("value1", "value2", ...)\n        ...\n        )\n    ```\n\n    Explain:\n        Use the specified key column and the formulated enumeration value for partitioning.\n        1) Partition name only support [A-z0-9_]\n        2) Partition key column\'s type should be:\n            BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, LARGEINT, DATE, DATETIME, CHAR, VARCHAR\n        3) Partition is a collection of enumerated values, partition values cannot be duplicated between partitions\n        4) NULL values cannot be imported\n        5) partition values cannot be defaulted, at least one must be specified\n\n2) Multi-column partition\n    Syntax.\n\n    ```\n        PARTITION BY LIST(k1, k2)\n        (\n        PARTITION partition_name1 VALUES IN (("value1", "value2"), ("value1", "value2"), ...) ,\n        PARTITION partition_name2 VALUES IN (("value1", "value2"), ("value1", "value2"), ...)\n        ...\n        )\n    ```\n\n    Explain:\n        1) the partition of a multi-column partition is a collection of tuple enumeration values\n        2) The number of tuple values per partition must be equal to the number of columns in the partition\n        3) The other partitions are synchronized with the single column partition\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"distribution_desc\n1) Hash\nSyntax:\n",(0,i.kt)("inlineCode",{parentName:"p"},"DISTRIBUTED BY HASH (k1[,k2 ...]) [BUCKETS num]"),"\nExplain:\nThe default buckets is 10.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"PROPERTIES\n1) If ENGINE type is olap. User can specify storage medium, cooldown time and replication   number:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'```\nPROPERTIES (\n    "storage_medium" = "[SSD|HDD]",\n    ["storage_cooldown_time" = "yyyy-MM-dd HH:mm:ss"],\n    ["replication_num" = "3"],\n    ["replication_allocation" = "xxx"]\n    )\n```\n\nstorage_medium:         SSD or HDD, The default initial storage media can be specified by `default_storage_medium= XXX` in the fe configuration file `fe.conf`, or, if not, by default, HDD.\n                        Note: when FE configuration \'enable_strict_storage_medium_check\' is\' True \', if the corresponding storage medium is not set in the cluster, the construction clause \'Failed to find enough host in all backends with storage medium is SSD|HDD\'.\nstorage_cooldown_time:  If storage_medium is SSD, data will be automatically moved to HDD   when timeout.\n                        Default is 30 days.\n                        Format: "yyyy-MM-dd HH:mm:ss"\nreplication_num:        Replication number of a partition. Default is 3.\nreplication_allocation:     Specify the distribution of replicas according to the resource tag.\n\nIf table is not range partitions. This property takes on Table level. Or it will takes on   Partition level.\nUser can specify different properties for different partition by `ADD PARTITION` or     `MODIFY PARTITION` statements.\n')),(0,i.kt)("p",{parentName:"li"},"2) If Engine type is olap, user can set bloom filter index for column.\nBloom filter index will be used when query contains ",(0,i.kt)("inlineCode",{parentName:"p"},"IN")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"EQUAL"),".\nBloom filter index support key columns with type except TINYINT FLOAT DOUBLE, also  support value with REPLACE aggregation type."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'```\nPROPERTIES (\n    "bloom_filter_columns"="k1,k2,k3"\n)\n```\n')),(0,i.kt)("p",{parentName:"li"},"3) For Colocation Join:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'```\nPROPERTIES (\n    "colocate_with"="table1"\n)\n```\n')),(0,i.kt)("p",{parentName:"li"},"4) if you want to use the dynamic partitioning feature, specify it in properties. Note: Dynamic partitioning only supports RANGE partitions"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'```\nPROPERTIES (\n    "dynamic_partition.enable" = "true|false",\n    "dynamic_partition.time_unit" = "HOUR|DAY|WEEK|MONTH",\n    "dynamic_partition.end" = "${integer_value}",\n    "dynamic_partition.prefix" = "${string_value}",\n    "dynamic_partition.buckets" = "${integer_value}\n)    \n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"\ndynamic_partition.enable: specifies whether dynamic partitioning at the table level is enabled\ndynamic_partition.time_unit: used to specify the time unit for dynamically adding partitions, which can be selected as HOUR, DAY, WEEK, and MONTH.\n                              Attention: When the time unit is HOUR, the data type of partition column cannot be DATE.\ndynamic_partition.end: used to specify the number of partitions created in advance\ndynamic_partition.prefix: used to specify the partition name prefix to be created, such as the partition name prefix p, automatically creates the partition name p20200108\ndynamic_partition.buckets: specifies the number of partition buckets that are automatically created\ndynamic_partition.create_history_partition: specifies whether create history partitions, default value is false\ndynamic_partition.history_partition_num: used to specify the number of history partitions when enable create_history_partition\ndynamic_partition.reserved_history_periods: Used to specify the range of reserved history periods\n")),(0,i.kt)("p",{parentName:"li"},"5)  You can create multiple Rollups in bulk when building a table\ngrammar:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'  ROLLUP (rollup_name (column_name1, column_name2, ...)\n                 [FROM from_index_name]\n                  [PROPERTIES ("key"="value", ...)],...)\n')),(0,i.kt)("p",{parentName:"li"},"6) if you want to use the inmemory table feature, specify it in properties"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'```\nPROPERTIES (\n   "in_memory"="true"\n)   \n```\n')))),(0,i.kt)("h2",{id:"example"},"example"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create an olap table, distributed by hash, with aggregation type."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'CREATE TABLE example_db.table_hash\n(\nk1 BOOLEAN,\nk2 TINYINT,\nk3 DECIMAL(10, 2) DEFAULT "10.5",\nv1 CHAR(10) REPLACE,\nv2 INT SUM\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2, k3)\nCOMMENT "my first doris table"\nDISTRIBUTED BY HASH(k1) BUCKETS 32;\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create an olap table, distributed by hash, with aggregation type. Also set storage medium and cooldown time."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'CREATE TABLE example_db.table_hash\n(\nk1 BIGINT,\nk2 LARGEINT,\nv1 VARCHAR(2048) REPLACE,\nv2 SMALLINT SUM DEFAULT "10"\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2)\nDISTRIBUTED BY HASH (k1, k2) BUCKETS 32\nPROPERTIES(\n"storage_medium" = "SSD",\n"storage_cooldown_time" = "2015-06-04 00:00:00"\n);\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create an olap table, with range partitioned, distributed by hash. Records with the same key exist at the same time, set the initial storage medium and cooling time, use default column storage."))),(0,i.kt)("p",null,"1) LESS THAN"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'```\nCREATE TABLE example_db.table_range\n(\nk1 DATE,\nk2 INT,\nk3 SMALLINT,\nv1 VARCHAR(2048),\nv2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nENGINE=olap\nDUPLICATE KEY(k1, k2, k3)\nPARTITION BY RANGE (k1)\n(\nPARTITION p1 VALUES LESS THAN ("2014-01-01"),\nPARTITION p2 VALUES LESS THAN ("2014-06-01"),\nPARTITION p3 VALUES LESS THAN ("2014-12-01")\n)\nDISTRIBUTED BY HASH(k2) BUCKETS 32\nPROPERTIES(\n"storage_medium" = "SSD", "storage_cooldown_time" = "2015-06-04 00:00:00"\n);\n```\n\nExplain:\nThis statement will create 3 partitions:\n\n```\n( {    MIN     },   {"2014-01-01"} )\n[ {"2014-01-01"},   {"2014-06-01"} )\n[ {"2014-06-01"},   {"2014-12-01"} )\n```\n\nData outside these ranges will not be loaded.\n')),(0,i.kt)("p",null,"2) Fixed Range"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'```\nCREATE TABLE table_range\n(\nk1 DATE,\nk2 INT,\nk3 SMALLINT,\nv1 VARCHAR(2048),\nv2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nENGINE=olap\nDUPLICATE KEY(k1, k2, k3)\nPARTITION BY RANGE (k1, k2, k3)\n(\nPARTITION p1 VALUES [("2014-01-01", "10", "200"), ("2014-01-01", "20", "300")),\nPARTITION p2 VALUES [("2014-06-01", "100", "200"), ("2014-07-01", "100", "300"))\n)\nDISTRIBUTED BY HASH(k2) BUCKETS 32\nPROPERTIES(\n"storage_medium" = "SSD"\n);\n```\n')),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create an olap table, with list partitioned, distributed by hash. Records with the same key exist at the same time, set the initial storage medium and cooling time, use default column storage."),(0,i.kt)("p",{parentName:"li"},"1) Single column partition"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'CREATE TABLE example_db.table_list\n(\nk1 INT,\nk2 VARCHAR(128),\nk3 SMALLINT,\nv1 VARCHAR(2048),\nv2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nENGINE=olap\nDUPLICATE KEY(k1, k2, k3)\nPARTITION BY LIST (k1)\n(\nPARTITION p1 VALUES IN ("1", "2", "3"),\nPARTITION p2 VALUES IN ("4", "5", "6"),\nPARTITION p3 VALUES IN ("7", "8", "9")\n)\nDISTRIBUTED BY HASH(k2) BUCKETS 32\nPROPERTIES(\n"storage_medium" = "SSD", "storage_cooldown_time" = "2022-06-04 00:00:00"\n);\n')),(0,i.kt)("p",{parentName:"li"},"Explain:\nThis statement will divide the data into 3 partitions as follows."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'("1", "2", "3")\n("4", "5", "6")\n("7", "8", "9")\n')),(0,i.kt)("p",{parentName:"li"},"Data that does not fall within these partition enumeration values will be filtered as illegal data"),(0,i.kt)("p",{parentName:"li"},"2) Multi-column partition"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'CREATE TABLE example_db.table_list\n(\nk1 INT,\nk2 VARCHAR(128),\nk3 SMALLINT,\nv1 VARCHAR(2048),\nv2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nENGINE=olap\nDUPLICATE KEY(k1, k2, k3)\nPARTITION BY LIST (k1, k2)\n(\nPARTITION p1 VALUES IN (("1", "beijing"), ("1", "shanghai")),\nPARTITION p2 VALUES IN (("2", "beijing"), ("2", "shanghai")),\nPARTITION p3 VALUES IN (("3", "beijing"), ("3", "shanghai"))\n)\nDISTRIBUTED BY HASH(k2) BUCKETS 32\nPROPERTIES(\n"storage_medium" = "SSD", "storage_cooldown_time" = "2022-06-04 00:00:00"\n);\n')),(0,i.kt)("p",{parentName:"li"},"Explain:\nThis statement will divide the data into 3 partitions as follows."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'(("1", "beijing"), ("1", "shanghai"))\n(("2", "beijing"), ("2", "shanghai"))\n(("3", "beijing"), ("3", "shanghai"))\n')),(0,i.kt)("p",{parentName:"li"},"Data that is not within these partition enumeration values will be filtered as illegal data")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a mysql table\n5.1 Create MySQL table directly from external table information"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'    CREATE EXTERNAL TABLE example_db.table_mysql\n    (\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    k4 VARCHAR(2048),\n    k5 DATETIME\n    )\n    ENGINE=mysql\n    PROPERTIES\n    (\n    "host" = "127.0.0.1",\n    "port" = "8239",\n    "user" = "mysql_user",\n    "password" = "mysql_passwd",\n    "database" = "mysql_db_test",\n    "table" = "mysql_table_test"\n    )\n')),(0,i.kt)("p",null,"   5.2 Create MySQL table with external ODBC catalog resource"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'   CREATE EXTERNAL RESOURCE "mysql_resource" \n   PROPERTIES\n   (\n     "type" = "odbc_catalog",\n     "user" = "mysql_user",\n     "password" = "mysql_passwd",\n     "host" = "127.0.0.1",\n     "port" = "8239"            \n   );\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'    CREATE EXTERNAL TABLE example_db.table_mysql\n    (\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    k4 VARCHAR(2048),\n    k5 DATETIME\n    )\n    ENGINE=mysql\n    PROPERTIES\n    (\n    "odbc_catalog_resource" = "mysql_resource",\n    "database" = "mysql_db_test",\n    "table" = "mysql_table_test"\n    )\n')),(0,i.kt)("ol",{start:6},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},'Create a broker table, with file on HDFS, line delimit by "|", column separated by "\\n"'),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'CREATE EXTERNAL TABLE example_db.table_broker (\nk1 DATE,\nk2 INT,\nk3 SMALLINT,\nk4 VARCHAR(2048),\nk5 DATETIME\n)\nENGINE=broker\nPROPERTIES (\n"broker_name" = "hdfs",\n"path" = "hdfs://hdfs_host:hdfs_port/data1,hdfs://hdfs_host:hdfs_port/data2,hdfs://hdfs_host:hdfs_port/data3%2c4",\n"column_separator" = "|",\n"line_delimiter" = "\\n"\n)\nBROKER PROPERTIES (\n"username" = "hdfs_user",\n"password" = "hdfs_password"\n);\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create table will HLL column"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'CREATE TABLE example_db.example_table\n(\nk1 TINYINT,\nk2 DECIMAL(10, 2) DEFAULT "10.5",\nv1 HLL HLL_UNION,\nv2 HLL HLL_UNION\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2)\nDISTRIBUTED BY HASH(k1) BUCKETS 32;\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a table will BITMAP_UNION column"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'CREATE TABLE example_db.example_table\n(\nk1 TINYINT,\nk2 DECIMAL(10, 2) DEFAULT "10.5",\nv1 BITMAP BITMAP_UNION,\nv2 BITMAP BITMAP_UNION\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2)\nDISTRIBUTED BY HASH(k1) BUCKETS 32;\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create 2 colocate join table."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'CREATE TABLE `t1` (\n`id` int(11) COMMENT "",\n`value` varchar(8) COMMENT ""\n) ENGINE=OLAP\nDUPLICATE KEY(`id`)\nDISTRIBUTED BY HASH(`id`) BUCKETS 10\nPROPERTIES (\n"colocate_with" = "group1"\n);\nCREATE TABLE `t2` (\n`id` int(11) COMMENT "",\n`value` varchar(8) COMMENT ""\n) ENGINE=OLAP\nDUPLICATE KEY(`id`)\nDISTRIBUTED BY HASH(`id`) BUCKETS 10\nPROPERTIES (\n"colocate_with" = "group1"\n);\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a broker table, with file on BOS."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'CREATE EXTERNAL TABLE example_db.table_broker (\nk1 DATE\n)\nENGINE=broker\nPROPERTIES (\n"broker_name" = "bos",\n"path" = "bos://my_bucket/input/file",\n)\nBROKER PROPERTIES (\n  "bos_endpoint" = "http://bj.bcebos.com",\n  "bos_accesskey" = "xxxxxxxxxxxxxxxxxxxxxxxxxx",\n  "bos_secret_accesskey"="yyyyyyyyyyyyyyyyyyyy"\n);\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a table with a bitmap index "),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'CREATE TABLE example_db.table_hash\n(\nk1 TINYINT,\nk2 DECIMAL(10, 2) DEFAULT "10.5",\nv1 CHAR(10) REPLACE,\nv2 INT SUM,\nINDEX k1_idx (k1) USING BITMAP COMMENT \'xxxxxx\'\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2)\nCOMMENT "my first doris table"\nDISTRIBUTED BY HASH(k1) BUCKETS 32;\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a dynamic partitioning table (dynamic partitioning needs to be enabled in FE configuration), which creates partitions 3 days in advance every day. For example, if today is' 2020-01-08 ', partitions named 'p20200108', 'p20200109', 'p20200110', 'p20200111' will be created."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"[types: [DATE]; keys: [2020-01-08]; \u2025types: [DATE]; keys: [2020-01-09]; )\n[types: [DATE]; keys: [2020-01-09]; \u2025types: [DATE]; keys: [2020-01-10]; )\n[types: [DATE]; keys: [2020-01-10]; \u2025types: [DATE]; keys: [2020-01-11]; )\n[types: [DATE]; keys: [2020-01-11]; \u2025types: [DATE]; keys: [2020-01-12]; )\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'   CREATE TABLE example_db.dynamic_partition\n   (\n   k1 DATE,\n   k2 INT,\n   k3 SMALLINT,\n   v1 VARCHAR(2048),\n   v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n   )\n   ENGINE=olap\n   DUPLICATE KEY(k1, k2, k3)\n   PARTITION BY RANGE (k1) ()\n   DISTRIBUTED BY HASH(k2) BUCKETS 32\n   PROPERTIES(\n   "storage_medium" = "SSD",\n   "dynamic_partition.time_unit" = "DAY",\n   "dynamic_partition.end" = "3",\n   "dynamic_partition.prefix" = "p",\n   "dynamic_partition.buckets" = "32"\n    );\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a table with rollup index"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    CREATE TABLE example_db.rolup_index_table\n    (\n        event_day DATE,\n        siteid INT DEFAULT '10',\n        citycode SMALLINT,\n        username VARCHAR(32) DEFAULT '',\n        pv BIGINT SUM DEFAULT '0'\n    )\n    AGGREGATE KEY(event_day, siteid, citycode, username)\n    DISTRIBUTED BY HASH(siteid) BUCKETS 10\n    rollup (\n    r1(event_day,siteid),\n    r2(event_day,citycode),\n    r3(event_day)\n    )\n    PROPERTIES(\"replication_num\" = \"3\");\n")),(0,i.kt)("ol",{start:14},(0,i.kt)("li",{parentName:"ol"},"Create a inmemory table:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'    CREATE TABLE example_db.table_hash\n    (\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    v1 CHAR(10) REPLACE,\n    v2 INT SUM,\n    INDEX k1_idx (k1) USING BITMAP COMMENT \'xxxxxx\'\n    )\n    ENGINE=olap\n    AGGREGATE KEY(k1, k2)\n    COMMENT "my first doris table"\n    DISTRIBUTED BY HASH(k1) BUCKETS 32\n    PROPERTIES ("in_memory"="true");\n')),(0,i.kt)("ol",{start:15},(0,i.kt)("li",{parentName:"ol"},"Create a hive external table")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'    CREATE TABLE example_db.table_hive\n    (\n      k1 TINYINT,\n      k2 VARCHAR(50),\n      v INT\n    )\n    ENGINE=hive\n    PROPERTIES\n    (\n      "database" = "hive_db_name",\n      "table" = "hive_table_name",\n      "hive.metastore.uris" = "thrift://127.0.0.1:9083"\n    );\n')),(0,i.kt)("ol",{start:16},(0,i.kt)("li",{parentName:"ol"},"Specify the replica distribution of the table through replication_allocation")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'    CREATE TABLE example_db.table_hash\n    (\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5"\n    )\n    DISTRIBUTED BY HASH(k1) BUCKETS 32\n    PROPERTIES (\n        "replication_allocation"="tag.location.group_a:1, tag.location.group_b:2"\n    );\n\n    CREATE TABLE example_db.dynamic_partition\n    (\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048),\n    v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n    )\n    PARTITION BY RANGE (k1) ()\n    DISTRIBUTED BY HASH(k2) BUCKETS 32\n    PROPERTIES(\n    "dynamic_partition.time_unit" = "DAY",\n    "dynamic_partition.start" = "-3",\n    "dynamic_partition.end" = "3",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "32",\n    "dynamic_partition."replication_allocation" = "tag.location.group_a:3"\n     );\n')),(0,i.kt)("h2",{id:"keyword"},"keyword"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"CREATE,TABLE\n")))}E.isMDXComponent=!0}}]);