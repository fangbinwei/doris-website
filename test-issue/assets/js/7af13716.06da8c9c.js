"use strict";(self.webpackChunkselectdb_portal=self.webpackChunkselectdb_portal||[]).push([[9551],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(t),m=r,g=p["".concat(s,".").concat(m)]||p[m]||d[m]||l;return t?a.createElement(g,o(o({ref:n},u),{},{components:t})):a.createElement(g,o({ref:n},u))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,o=new Array(l);o[0]=m;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[p]="string"==typeof e?e:r,o[1]=i;for(var c=2;c<l;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},45429:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var a=t(87462),r=(t(67294),t(3905));const l={title:"window function",language:"en"},o=void 0,i={unversionedId:"sql-reference/sql-functions/window-function",id:"version-0.15/sql-reference/sql-functions/window-function",title:"window function",description:'\x3c!--  Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at',source:"@site/versioned_docs/version-0.15/sql-reference/sql-functions/window-function.md",sourceDirName:"sql-reference/sql-functions",slug:"/sql-reference/sql-functions/window-function",permalink:"/docs/0.15/sql-reference/sql-functions/window-function",draft:!1,tags:[],version:"0.15",frontMatter:{title:"window function",language:"en"},sidebar:"docs",previous:{title:"murmur_hash3_32",permalink:"/docs/0.15/sql-reference/sql-functions/hash-functions/murmur_hash3_32"},next:{title:"CAST",permalink:"/docs/0.15/sql-reference/sql-functions/cast"}},s={},c=[{value:"Window function introduction",id:"window-function-introduction",level:2},{value:"Function",id:"function",level:3},{value:"Partition By clause",id:"partition-by-clause",level:3},{value:"Order By clause",id:"order-by-clause",level:3},{value:"Window clause",id:"window-clause",level:3},{value:"Example:",id:"example",level:3},{value:"Function example",id:"function-example",level:2},{value:"AVG()",id:"avg",level:3},{value:"COUNT()",id:"count",level:3},{value:"DENSE_RANK()",id:"dense_rank",level:3},{value:"FIRST_VALUE()",id:"first_value",level:3},{value:"LAG()",id:"lag",level:3},{value:"LAST_VALUE()",id:"last_value",level:3},{value:"LEAD()",id:"lead",level:3},{value:"MAX()",id:"max",level:3},{value:"MIN()",id:"min",level:3},{value:"RANK()",id:"rank",level:3},{value:"ROW_NUMBER()",id:"row_number",level:3},{value:"SUM()",id:"sum",level:3}],u={toc:c};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"doris-window-function-usage"},"Doris Window function usage"),(0,r.kt)("h2",{id:"window-function-introduction"},"Window function introduction"),(0,r.kt)("p",null,"Analysis functions are a special kind of built-in functions. Similar to the aggregation function, the analysis function also calculates a data value for multiple input rows. The difference is that the analysis function processes the input data in a specific window instead of grouping calculations according to group by. The data in each window can be sorted and grouped using the over() clause. The analysis function calculates a separate value for each row of the result set, instead of calculating a value for each group by group. This flexible way allows users to add additional columns in the select clause, giving users more opportunities to reorganize and filter the result set. Analysis functions can only appear in the select list and the outermost order by clause. In the query process, the analysis function will take effect at the end, that is, it will be executed after the join, where and group  by operations are completed. Analytical functions are often used in the fields of finance and scientific computing to analyze trends, calculate outliers, and perform bucket analysis on large amounts of data."),(0,r.kt)("p",null,"The syntax of the analysis function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"function(args) OVER(partition_by_clause order_by_clause [window_clause])    \npartition_by_clause ::= PARTITION BY expr [, expr ...]    \norder_by_clause ::= ORDER BY expr [ASC | DESC] [, expr [ASC | DESC] ...]\n")),(0,r.kt)("h3",{id:"function"},"Function"),(0,r.kt)("p",null,"Currently supported functions include AVG(), COUNT(), DENSE_RANK(), FIRST_VALUE(), LAG(), LAST_VALUE(), LEAD(), MAX(), MIN(), RANK(), ROW_NUMBER() and SUM ()."),(0,r.kt)("h3",{id:"partition-by-clause"},"Partition By clause"),(0,r.kt)("p",null,"The Partition By clause is similar to Group By. It groups the input rows according to the specified one or more columns, and rows with the same value will be grouped into a group."),(0,r.kt)("h3",{id:"order-by-clause"},"Order By clause"),(0,r.kt)("p",null,"The Order By clause is basically the same as the outer Order By. It defines the order of the input rows. If Partition By is specified, Order By defines the order within each Partition group. The only difference with the outer Order By is that the Order By n (n is a positive integer) in the OVER clause is equivalent to doing nothing, while the outer Order By n means sorting according to the nth column."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"This example shows the addition of an id column to the select list, its value is 1, 2, 3, etc., in order according to the date_and_time column in the events table."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT   \nrow_number() OVER (ORDER BY date_and_time) AS id,   \nc1, c2, c3, c4   \nFROM events;\n")),(0,r.kt)("h3",{id:"window-clause"},"Window clause"),(0,r.kt)("p",null,"The Window clause is used to specify an operation range for the analysis function, based on the current behavior, and several lines before and after the analysis function as the object of operation. The methods supported by the Window clause are: AVG(), COUNT(), FIRST_VALUE(), LAST_VALUE() and SUM(). For MAX() and MIN(), the window clause can specify the start range UNBOUNDED PRECEDING"),(0,r.kt)("p",null,"grammar:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"ROWS BETWEEN [ { m | UNBOUNDED } PRECEDING | CURRENT ROW] [ AND [CURRENT ROW | { UNBOUNDED | n } FOLLOWING] ]\n")),(0,r.kt)("h3",{id:"example"},"Example:"),(0,r.kt)("p",null,"Suppose we have the following stock data, the stock code is JDR, and the closing price is the daily closing price."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create table stock_ticker (stock_symbol string, closing_price decimal(8,2), closing_date timestamp);    \n...load some data...    \nselect * from stock_ticker order by stock_symbol, closing_date\n | stock_symbol | closing_price | closing_date        |\n |--------------|---------------|---------------------|\n | JDR          | 12.86         | 2014-10-02 00:00:00 |\n | JDR          | 12.89         | 2014-10-03 00:00:00 |\n | JDR          | 12.94         | 2014-10-04 00:00:00 |\n | JDR          | 12.55         | 2014-10-05 00:00:00 |\n | JDR          | 14.03         | 2014-10-06 00:00:00 |\n | JDR          | 14.75         | 2014-10-07 00:00:00 |\n | JDR          | 13.98         | 2014-10-08 00:00:00 |\n")),(0,r.kt)("p",null,"This query uses an analytical function to generate the moving_average column, and its value is the average price of stocks in 3 days, that is, the average price of the previous day, the current day, and the next day. The first day does not have the value of the previous day, and the last day does not have the value of the next day, so these two rows only calculate the average of the two days. Here Partition By does not play a role, because all the data is JDR data, but if there is other stock information, Partition By will ensure that the analysis function value is applied to this Partition."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select stock_symbol, closing_date, closing_price,    \navg(closing_price) over (partition by stock_symbol order by closing_date    \nrows between 1 preceding and 1 following) as moving_average    \nfrom stock_ticker;\n | stock_symbol | closing_date        | closing_price | moving_average |\n |--------------|---------------------|---------------|----------------|\n | JDR          | 2014-10-02 00:00:00 | 12.86         | 12.87          |\n | JDR          | 2014-10-03 00:00:00 | 12.89         | 12.89          |\n | JDR          | 2014-10-04 00:00:00 | 12.94         | 12.79          |\n | JDR          | 2014-10-05 00:00:00 | 12.55         | 13.17          |\n | JDR          | 2014-10-06 00:00:00 | 14.03         | 13.77          |\n | JDR          | 2014-10-07 00:00:00 | 14.75         | 14.25          |\n | JDR          | 2014-10-08 00:00:00 | 13.98         | 14.36          |\n")),(0,r.kt)("h2",{id:"function-example"},"Function example"),(0,r.kt)("p",null,"This section introduces the methods that can be used as analysis functions in Doris."),(0,r.kt)("h3",{id:"avg"},"AVG()"),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"AVG([DISTINCT | ALL] *expression*) [OVER (*analytic_clause*)]\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"Calculate the x average value of the current row and each row of data before and after it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select x, property,    \navg(x) over    \n(   \npartition by property    \norder by x    \nrows between 1 preceding and 1 following    \n) as 'moving average'    \nfrom int_t where property in ('odd','even');\n | x  | property | moving average |\n |----|----------|----------------|\n | 2  | even     | 3              |\n | 4  | even     | 4              |\n | 6  | even     | 6              |\n | 8  | even     | 8              |\n | 10 | even     | 9              |\n | 1  | odd      | 2              |\n | 3  | odd      | 3              |\n | 5  | odd      | 5              |\n | 7  | odd      | 7              |\n | 9  | odd      | 8              |\n")),(0,r.kt)("h3",{id:"count"},"COUNT()"),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"COUNT([DISTINCT | ALL] expression) [OVER (analytic_clause)]\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"Count the number of occurrences of x from the current line to the first line."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select x, property,   \ncount(x) over   \n(   \npartition by property    \norder by x    \nrows between unbounded preceding and current row    \n) as 'cumulative total'    \nfrom int_t where property in ('odd','even');\n | x  | property | cumulative count |\n |----|----------|------------------|\n | 2  | even     | 1                |\n | 4  | even     | 2                |\n | 6  | even     | 3                |\n | 8  | even     | 4                |\n | 10 | even     | 5                |\n | 1  | odd      | 1                |\n | 3  | odd      | 2                |\n | 5  | odd      | 3                |\n | 7  | odd      | 4                |\n | 9  | odd      | 5                |\n")),(0,r.kt)("h3",{id:"dense_rank"},"DENSE_RANK()"),(0,r.kt)("p",null,"The DENSE_RANK() function is used to indicate the ranking. Unlike RANK(), DENSE_RANK() does not have vacant numbers. For example, if there are two parallel ones, the third number of DENSE_RANK() is still 2, and the third number of RANK() is 3."),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"DENSE_RANK() OVER(partition_by_clause order_by_clause)\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"The following example shows the ranking of the x column grouped by the property column:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"}," select x, y, dense_rank() over(partition by x order by y) as rank from int_t;\n | x  | y    | rank     |\n |----|------|----------|\n | 1  | 1    | 1        |\n | 1  | 2    | 2        |\n | 1  | 2    | 2        |\n | 2  | 1    | 1        |\n | 2  | 2    | 2        |\n | 2  | 3    | 3        |\n | 3  | 1    | 1        |\n | 3  | 1    | 1        |\n | 3  | 2    | 2        |\n")),(0,r.kt)("h3",{id:"first_value"},"FIRST_VALUE()"),(0,r.kt)("p",null,"FIRST_VALUE() returns the first value in the window range."),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"FIRST_VALUE(expr) OVER(partition_by_clause order_by_clause [window_clause])\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"We have the following data"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"}," select name, country, greeting from mail_merge;\n | name    | country | greeting     |\n |---------|---------|--------------|\n | Pete    | USA     | Hello        |\n | John    | USA     | Hi           |\n | Boris   | Germany | Guten tag    |\n | Michael | Germany | Guten morgen |\n | Bjorn   | Sweden  | Hej          |\n | Mats    | Sweden  | Tja          |\n")),(0,r.kt)("p",null,"Use FIRST_VALUE() to group by country and return the value of the first greeting in each group\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select country, name,    \nfirst_value(greeting)    \nover (partition by country order by name, greeting) as greeting from mail_merge;\n| country | name    | greeting  |\n|---------|---------|-----------|\n| Germany | Boris   | Guten tag |\n| Germany | Michael | Guten tag |\n| Sweden  | Bjorn   | Hej       |\n| Sweden  | Mats    | Hej       |\n| USA     | John    | Hi        |\n| USA     | Pete    | Hi        |\n")),(0,r.kt)("h3",{id:"lag"},"LAG()"),(0,r.kt)("p",null,"The LAG() method is used to calculate the value of several lines forward from the current line."),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"LAG (expr, offset, default) OVER (partition_by_clause order_by_clause)\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"Calculate the closing price of the previous day"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'select stock_symbol, closing_date, closing_price,    \nlag(closing_price,1, 0) over (partition by stock_symbol order by closing_date) as "yesterday closing"   \nfrom stock_ticker   \norder by closing_date;\n| stock_symbol | closing_date        | closing_price | yesterday closing |\n|--------------|---------------------|---------------|-------------------|\n| JDR          | 2014-09-13 00:00:00 | 12.86         | 0                 |\n| JDR          | 2014-09-14 00:00:00 | 12.89         | 12.86             |\n| JDR          | 2014-09-15 00:00:00 | 12.94         | 12.89             |\n| JDR          | 2014-09-16 00:00:00 | 12.55         | 12.94             |\n| JDR          | 2014-09-17 00:00:00 | 14.03         | 12.55             |\n| JDR          | 2014-09-18 00:00:00 | 14.75         | 14.03             |\n| JDR          | 2014-09-19 00:00:00 | 13.98         | 14.75             |\n')),(0,r.kt)("h3",{id:"last_value"},"LAST_VALUE()"),(0,r.kt)("p",null,"LAST_VALUE() returns the last value in the window range. Contrary to FIRST_VALUE()."),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"LAST_VALUE(expr) OVER(partition_by_clause order_by_clause [window_clause])\n")),(0,r.kt)("p",null,"Use the data in the FIRST_VALUE() example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select country, name,    \nlast_value(greeting)   \nover (partition by country order by name, greeting) as greeting   \nfrom mail_merge;\n| country | name    | greeting     |\n|---------|---------|--------------|\n| Germany | Boris   | Guten morgen |\n| Germany | Michael | Guten morgen |\n| Sweden  | Bjorn   | Tja          |\n| Sweden  | Mats    | Tja          |\n| USA     | John    | Hello        |\n| USA     | Pete    | Hello        |\n")),(0,r.kt)("h3",{id:"lead"},"LEAD()"),(0,r.kt)("p",null,"The LEAD() method is used to calculate the value of several rows from the current row."),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"LEAD (expr, offset, default]) OVER (partition_by_clause order_by_clause)\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"Calculate the trend of the closing price of the next day compared to the closing price of the day, that is, whether the closing price of the next day is higher or lower than that of the day."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'select stock_symbol, closing_date, closing_price,    \ncase   \n(lead(closing_price,1, 0)   \nover (partition by stock_symbol order by closing_date)-closing_price) > 0   \nwhen true then "higher"   \nwhen false then "flat or lower"    \nend as "trending"   \nfrom stock_ticker    \norder by closing_date;\n| stock_symbol | closing_date        | closing_price | trending      |\n|--------------|---------------------|---------------|---------------|\n| JDR          | 2014-09-13 00:00:00 | 12.86         | higher        |\n| JDR          | 2014-09-14 00:00:00 | 12.89         | higher        |\n| JDR          | 2014-09-15 00:00:00 | 12.94         | flat or lower |\n| JDR          | 2014-09-16 00:00:00 | 12.55         | higher        |\n| JDR          | 2014-09-17 00:00:00 | 14.03         | higher        |\n| JDR          | 2014-09-18 00:00:00 | 14.75         | flat or lower |\n| JDR          | 2014-09-19 00:00:00 | 13.98         | flat or lower |\n')),(0,r.kt)("h3",{id:"max"},"MAX()"),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"MAX([DISTINCT | ALL] expression) [OVER (analytic_clause)]\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"Calculate the maximum value from the first line to the line after the current line"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select x, property,   \nmax(x) over    \n(   \norder by property, x    \nrows between unbounded preceding and 1 following    \n) as 'local maximum'    \nfrom int_t where property in ('prime','square');\n| x | property | local maximum |\n|---|----------|---------------|\n| 2 | prime    | 3             |\n| 3 | prime    | 5             |\n| 5 | prime    | 7             |\n| 7 | prime    | 7             |\n| 1 | square   | 7             |\n| 4 | square   | 9             |\n| 9 | square   | 9             |\n")),(0,r.kt)("h3",{id:"min"},"MIN()"),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"MIN([DISTINCT | ALL] expression) [OVER (analytic_clause)]\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"Calculate the minimum value from the first line to the line after the current line"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select x, property,   \nmin(x) over    \n(    \norder by property, x desc    \nrows between unbounded preceding and 1 following   \n) as 'local minimum'   \nfrom int_t where property in ('prime','square');\n| x | property | local minimum |\n|---|----------|---------------|\n| 7 | prime    | 5             |\n| 5 | prime    | 3             |\n| 3 | prime    | 2             |\n| 2 | prime    | 2             |\n| 9 | square   | 2             |\n| 4 | square   | 1             |\n| 1 | square   | 1             |\n")),(0,r.kt)("h3",{id:"rank"},"RANK()"),(0,r.kt)("p",null,"The RANK() function is used to indicate ranking. Unlike DENSE_RANK(), RANK() will have vacant numbers. For example, if there are two parallel 1s, the third number in RANK() is 3, not 2."),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"RANK() OVER(partition_by_clause order_by_clause)\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"Rank according to x"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select x, y, rank() over(partition by x order by y) as rank from int_t;\n| x  | y    | rank     |\n|----|------|----------|\n| 1  | 1    | 1        |\n| 1  | 2    | 2        |\n| 1  | 2    | 2        |\n| 2  | 1    | 1        |\n| 2  | 2    | 2        |\n| 2  | 3    | 3        |\n| 3  | 1    | 1        |\n| 3  | 1    | 1        |\n| 3  | 2    | 3        |\n")),(0,r.kt)("h3",{id:"row_number"},"ROW_NUMBER()"),(0,r.kt)("p",null,"For each row of each Partition, an integer that starts from 1 and increases continuously is returned. Unlike RANK() and DENSE_RANK(), the value returned by ROW_NUMBER() will not be repeated or vacant, and is continuously increasing."),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"ROW_NUMBER() OVER(partition_by_clause order_by_clause)\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select x, y, row_number() over(partition by x order by y) as rank from int_t;\n| x | y    | rank     |\n|---|------|----------|\n| 1 | 1    | 1        |\n| 1 | 2    | 2        |\n| 1 | 2    | 3        |\n| 2 | 1    | 1        |\n| 2 | 2    | 2        |\n| 2 | 3    | 3        |\n| 3 | 1    | 1        |\n| 3 | 1    | 2        |\n| 3 | 2    | 3        |\n")),(0,r.kt)("h3",{id:"sum"},"SUM()"),(0,r.kt)("p",null,"grammar\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SUM([DISTINCT | ALL] expression) [OVER (analytic_clause)]\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("p",null,"Group according to property, and calculate the sum of the x column of the current row and each row before and after in the group."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select x, property,   \nsum(x) over    \n(   \npartition by property   \norder by x   \nrows between 1 preceding and 1 following    \n) as 'moving total'    \nfrom int_t where property in ('odd','even');\n| x  | property | moving total |\n|----|----------|--------------|\n| 2  | even     | 6            |\n| 4  | even     | 12           |\n| 6  | even     | 18           |\n| 8  | even     | 24           |\n| 10 | even     | 18           |\n| 1  | odd      | 4            |\n| 3  | odd      | 9            |\n| 5  | odd      | 15           |\n| 7  | odd      | 21           |\n| 9  | odd      | 16           |\n")))}p.isMDXComponent=!0}}]);